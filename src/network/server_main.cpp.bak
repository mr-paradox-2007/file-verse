#include <iostream>
#include <string>
#include <sstream>
#include <cstring>
#include <cstdlib>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <ctime>
#include <cerrno>
#include "fs_init.hpp"
#include "file_ops.hpp"
#include "user_manager.hpp"
#include "logger.hpp"

OFS_Instance g_fs_instance = nullptr;

// JSON helpers
std::string extract_json_string(const std::string& json_str, const std::string& key) {
    size_t pos = json_str.find("\"" + key + "\"");
    if (pos == std::string::npos) return "";
    
    pos = json_str.find(":", pos);
    pos = json_str.find("\"", pos);
    size_t end_pos = json_str.find("\"", pos + 1);
    
    if (pos != std::string::npos && end_pos != std::string::npos) {
        return json_str.substr(pos + 1, end_pos - pos - 1);
    }
    return "";
}

std::string json_response(const std::string& status, const std::string& message) {
    std::string response = "{\"status\":\"" + status + "\",\"message\":\"" + message + "\"}";
    return response;
}

std::string json_response_with_data(const std::string& status, const std::string& message,
                                    const std::string& data_key, const std::string& data_value) {
    std::string response = "{\"status\":\"" + status + "\",\"message\":\"" + message + "\",\"" +
                          data_key + "\":\"" + data_value + "\"}";
    return response;
}

// Handle HTTP request
std::string handle_request(const std::string& request_body, const std::string& request_path) {
    std::cout << "    [DEBUG] handle_request: path=" << request_path << std::endl;
    
    // Extract operation from path
    if (request_path == "/user/login") {
        std::cout << "    [DEBUG] Handling login" << std::endl;
        std::string username = extract_json_string(request_body, "username");
        std::string password = extract_json_string(request_body, "password");
        std::cout << "    [DEBUG] Extracted user: " << username << std::endl;
        
        OFS_Session session;
        std::cout << "    [DEBUG] Calling user_login" << std::endl;
        int result = user_login(&session, username, password);
        std::cout << "    [DEBUG] user_login returned: " << result << std::endl;
        
        if (result == static_cast<int>(OFSErrorCodes::SUCCESS)) {
            std::string role = "0";
            UserRole user_role;
            if (verify_session(session, username, user_role) == static_cast<int>(OFSErrorCodes::SUCCESS)) {
                role = std::to_string(static_cast<int>(user_role));
            }
            std::cout << "    [DEBUG] Returning success response" << std::endl;
            return json_response_with_data("success", "Login successful", "role", role);
        }
        std::cout << "    [DEBUG] Login failed, error: " << result << std::endl;
        return json_response("error", get_error_message(result));
    }
    
    else if (request_path == "/user/signup") {
        std::string username = extract_json_string(request_body, "username");
        std::string password = extract_json_string(request_body, "password");
        
        if (username.length() < 3 || username.length() > 31) {
            return json_response("error", "Username must be 3-31 characters");
        }
        if (password.length() < 4) {
            return json_response("error", "Password must be at least 4 characters");
        }
        
        // TODO: Use admin session to create user
        // For now, just log it
        Logger::info("User signup attempted: " + username);
        return json_response("success", "Account created successfully");
    }
    
    else if (request_path == "/file/create") {
        std::string path = extract_json_string(request_body, "path");
        std::string content = extract_json_string(request_body, "content");
        
        int result = file_create(nullptr, path, (void*)content.c_str(), content.length());
        if (result == static_cast<int>(OFSErrorCodes::SUCCESS)) {
            return json_response("success", "File created successfully");
        }
        return json_response("error", get_error_message(result));
    }
    
    else if (request_path == "/file/read") {
        std::string path = extract_json_string(request_body, "path");
        
        void* buffer;
        size_t size;
        int result = file_read(nullptr, path, &buffer, &size);
        
        if (result == static_cast<int>(OFSErrorCodes::SUCCESS)) {
            std::string content((char*)buffer, size);
            free_buffer(buffer);
            return json_response_with_data("success", "File read successfully", "content", content);
        }
        return json_response("error", get_error_message(result));
    }
    
    else if (request_path == "/debug/users") {
        std::cout << "    [DEBUG] Handling debug/users" << std::endl;
        return json_response("success", "Debug users endpoint");
    }
    
    std::cout << "    [DEBUG] Unknown path: " << request_path << std::endl;
    return json_response("error", "Unknown endpoint: " + request_path);
}

// HTTP response formatter (now inline above)

// Client handler (runs in separate thread)
void* handle_client(void* arg) {
    int client_socket = *((int*)arg);
    delete (int*)arg;
    
    // Read HTTP request
    char buffer[8192];
    int bytes_read = recv(client_socket, buffer, sizeof(buffer) - 1, 0);
    
    if (bytes_read <= 0) {
        close(client_socket);
        return nullptr;
    }
    
    buffer[bytes_read] = '\0';
    std::string request(buffer);
    
    // Extract request line
    std::string method, path, http_version;
    size_t first_space = request.find(' ');
    size_t second_space = request.find(' ', first_space + 1);
    size_t first_newline = request.find('\n');
    
    if (first_space != std::string::npos && second_space != std::string::npos) {
        method = request.substr(0, first_space);
        path = request.substr(first_space + 1, second_space - first_space - 1);
        http_version = request.substr(second_space + 1, first_newline - second_space - 1);
    }
    
    // Extract body (after \r\n\r\n)
    size_t body_start = request.find("\r\n\r\n");
    std::string body;
    if (body_start != std::string::npos) {
        body = request.substr(body_start + 4);
    }
    
    std::cout << "[*] " << method << " " << path << std::endl;
    std::cout << "[DEBUG] Checking method: '" << method << "'" << std::endl;
    
    // Handle the request
    std::string response_body;
    if (method == "POST" || method == "GET") {
        std::cout << "[DEBUG] Calling handle_request" << std::endl;
        response_body = handle_request(body, path);
        std::cout << "[DEBUG] handle_request returned" << std::endl;
    } else {
        std::cout << "[DEBUG] Method not POST/GET" << std::endl;
        response_body = json_response("error", "Method not allowed");
    }
    
    // Format HTTP response
    std::stringstream response_stream;
    response_stream << "HTTP/1.1 200 OK\r\n";
    response_stream << "Content-Type: application/json\r\n";
    response_stream << "Content-Length: " << response_body.length() << "\r\n";
    response_stream << "Access-Control-Allow-Origin: *\r\n";
    response_stream << "Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n";
    response_stream << "Access-Control-Allow-Headers: Content-Type\r\n";
    response_stream << "Connection: close\r\n";
    response_stream << "\r\n";
    response_stream << response_body;
    
    std::string http_response = response_stream.str();
    send(client_socket, http_response.c_str(), http_response.length(), 0);
    
    close(client_socket);
    return nullptr;
}

int main(int argc, char** argv) {
    const int PORT = 9000;
    
    std::cout << "╔════════════════════════════════════════╗" << std::endl;
    std::cout << "║  OFS Server - Phase 1 Implementation   ║" << std::endl;
    std::cout << "╚════════════════════════════════════════╝" << std::endl;
    std::cout << std::endl;
    
    // Initialize file system
    std::cout << "[*] Initializing file system..." << std::endl;
    int init_result = fs_init(&g_fs_instance, "data/system.omni", "default.uconf", "my_secret_key");
    if (init_result != static_cast<int>(OFSErrorCodes::SUCCESS)) {
        std::cerr << "[!] Failed to initialize file system" << std::endl;
        return 1;
    }
    
    // Load users
    std::cout << "[*] Loading users..." << std::endl;
    load_users();
    
    // Create socket
    std::cout << "[*] Creating socket..." << std::endl;
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0) {
        std::cerr << "[!] Failed to create socket" << std::endl;
        return 1;
    }
    
    // Allow socket reuse
    int opt = 1;
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        std::cerr << "[!] Failed to set socket options" << std::endl;
        return 1;
    }
    
    // Bind socket
    struct sockaddr_in server_addr;
    std::memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    
    std::cout << "[*] Binding to port " << PORT << "..." << std::endl;
    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        std::cerr << "[!] Failed to bind socket" << std::endl;
        return 1;
    }
    
    // Listen for connections
    if (listen(server_socket, 20) < 0) {
        std::cerr << "[!] Listen failed" << std::endl;
        return 1;
    }
    
    std::cout << "[✓] Server started on port " << PORT << std::endl;
    std::cout << "[✓] Listening for connections..." << std::endl;
    std::cout << std::endl;
    
    // Accept client connections
    while (true) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_len = sizeof(client_addr);
        
        int* client_socket = new int;
        *client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_addr_len);
        
        if (*client_socket < 0) {
            delete client_socket;
            continue;
        }
        
        // Handle client in new thread
        pthread_t thread_id;
        pthread_create(&thread_id, nullptr, handle_client, (void*)client_socket);
        pthread_detach(thread_id);
    }
    
    close(server_socket);
    fs_shutdown(g_fs_instance);
    
    return 0;
}
